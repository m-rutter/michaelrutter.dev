<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="/style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
     <link rel="alternate" type="application/rss+xml" title="RSS"
    href="https://m-rutter.com/rss.xml"> 
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="icon" sizes="16x16 32x32 64x64" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="196x196" href="/favicon-192.png" />
    <link rel="icon" type="image/png" sizes="160x160" href="/favicon-160.png" />
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96.png" />
    <link rel="icon" type="image/png" sizes="64x64" href="/favicon-64.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png" />
    <link rel="apple-touch-icon" href="/favicon-57.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/favicon-114.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/favicon-72.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/favicon-144.png" />
    <link rel="apple-touch-icon" sizes="60x60" href="/favicon-60.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/favicon-120.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/favicon-76.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/favicon-152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon-180.png" />
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/favicon-144.png" />
    <meta name="msapplication-config" content="/browserconfig.xml" />

    <title> Some Michael => Typesafe Function Overloading in TypeScript </title>
  </head>
  <body class="wrapper">
    <nav class="nav-header">
      <h1 class="header-title mono f5 f3-ns f3-l">
        <a href="/">
          <span style="color: #ffa759">Some</span>(Michael) =>
          </span>
        </a>
      </h1>

      <ul class="nav-links">
        <li>
          <a
            class=""
            href="/"
            >blog</a
          >
        </li>
        <li>
          <a
            class=""
            href="/about/"
            >about</a
          >
        </li>
        <!-- <li><a class="" href="/projects">projects</a></li> -->
        <li>
          <a
            class=""
            href="/tags/"
            >tags</a
          >
        </li>
      </ul>
    </nav>

    <main class="main">
      
<article>
    <header class="post-header">
        <a href="https:&#x2F;&#x2F;m-rutter.com&#x2F;conditional-types-and-overloading&#x2F;">
            <h1 class="post-title f3">Typesafe Function Overloading in TypeScript</h1>
        </a>
        <h4 class="post-title f5">Common frustrations with no easy solution</h4>
        <section class="post-meta">
            <dl class="slab">
                <dt>Reading time</dt>
                <dd>10 minutes</dd>
            </dl>

            <dl class="slab">
                <dt>Published</dt>
                <dd>
                    <time datetime="2023-03-19"
                        >19 Mar 2023</time
                    >
                </dd>
            </dl>
            
        </section>
    </header>
    <section><p>When helping developers new to TypeScript, I encounter several common patterns
of frustration. Two broad categories:</p>
<ul>
<li>Type 1: Users get frustrated that certain JavaScript patterns are hard to
express safely in TypeScript. This typically involves runtime reflection,
which I won't discuss today and is usually an issue for less experienced or
stubborn users (sometimes legitimately!).</li>
<li>Type 2: Users understand TypeScript features in isolation but get confused
combining them in seemingly natural ways that don't work as expected. Often
this is simply because the feature combination hasn't been implemented.</li>
</ul>
<p>We'll focus on a type 2 problem: function overloading and conditional types in
TypeScript. This is an area many find unsatisfactory and I've seen attempted
countless times. The intersection of these features comes up often in the
TypeScript Discord and at work. The goal is type safety, but the result is
confusing compiler errors.</p>
<span id="continue-reading"></span><h2 id="some-prerequisites">Some prerequisites</h2>
<p>Before we jump in, let's have a quick refresher on three TypeScript features:
union types, generics, and conditional types. Feel free to skip if you're
already familiar with these concepts.</p>
<h3 id="union-types">Union types</h3>
<p>Union types in TypeScript allow you to define a type which can be one of several
types.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="color:#ffa759;">interface </span><span style="color:#73d0ff;">Yan </span><span>{
</span><span>  tan</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">YanTan </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">Yan </span><span style="color:#f29e74;">| </span><span style="color:#bae67e;">&quot;tan&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">Tethera </span><span style="color:#f29e74;">= </span><span>{ type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;yan&quot;</span><span style="color:#ccc9c2cc;">; </span><span>value</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string </span><span>} </span><span style="color:#f29e74;">| </span><span>{ type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;tan&quot;</span><span style="color:#ccc9c2cc;">; </span><span>value2</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number </span><span>}</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">declare const </span><span>tethera</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Tethera</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// using control flow narrowing to access the correct fields
</span><span style="color:#ffa759;">if </span><span>(t</span><span style="color:#f29e74;">.</span><span>type </span><span style="color:#f29e74;">=== </span><span style="color:#bae67e;">&quot;yan&quot;</span><span>) {
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// ok
</span><span>  t</span><span style="color:#f29e74;">.</span><span>value</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">toLowerCase</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// property &#39;value2&#39; does not exist on type &#39;{ type: &quot;yan&quot;; value: string; }&#39;
</span><span>  t</span><span style="color:#f29e74;">.</span><span>value2</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">toString</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>In the example above, <code>YanTan</code> is a union type that can either be a string
literal type <code>"tan"</code> or an object named <code>Yan</code>. The <code>Tethera</code> type is a union of
two different object types, distinguished by their common <code>type</code> property. This
latter example is typically called a discriminated union in TypeScript, and
elsewhere might be called tagged unions, disjoint unions, or sum types.
TypeScript uses the language's control flow constructs to "narrow" union types,
as demonstrated with the value <code>tethera</code> above.</p>
<p>For more on narrowing, the TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">handbook chapter on narrowing</a> is a
must read for new users:</p>
<h3 id="generics">Generics</h3>
<p>Generics in TypeScript provide a way to define reusable code that can work with
multiple types. They allow you to create functions or types that can operate on
those different types while preserving type information of the inputs in their
outputs.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="color:#ffa759;">function </span><span style="color:#ffd580;">map</span><span>&lt;</span><span style="color:#73d0ff;">T</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">U</span><span>&gt;(</span><span style="color:#ffcc66;">type</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">T</span><span>[]</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffd580;">callback</span><span style="color:#f29e74;">: </span><span>(</span><span style="color:#ffcc66;">t</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">T</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span style="color:#73d0ff;">U</span><span>)</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">U</span><span>[] {
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>}
</span><span>
</span><span style="color:#ffa759;">const </span><span>yan </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">map</span><span>(
</span><span>  </span><span style="font-style:italic;color:#5c6773;">//    ^? const yan: string[]
</span><span>  [</span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;&quot;</span><span>]</span><span style="color:#ccc9c2cc;">,
</span><span>  (</span><span style="color:#ffcc66;">value</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span>value</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">toString</span><span>()</span><span style="color:#ccc9c2cc;">,
</span><span>  </span><span style="font-style:italic;color:#5c6773;">//  ^? (parameter) value: number | string
</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>In this example, the <code>map</code> function takes an array of type <code>T</code> and a callback
that maps elements of type <code>T</code> to a different type <code>U</code>. The result is an array
of type <code>U</code>. This is basically the function signature of <code>Array.prototype.map</code>.
In our <code>yan</code> example, we are mapping an array of <code>number</code> and <code>string</code> to an
array of <code>string</code>, and at each step of the way TypeScript is able to infer the
types of the input and output of the callback function without any additional
type annotations.</p>
<h3 id="conditional-types">Conditional Types</h3>
<p>Conditional types in TypeScript allow you to create new types based on type
level conditions. They are a powerful way to express complex type relationships
by giving you a form of control flow in type level expressions of the language.
As an ordinary TypeScript user, it is not a feature you will often need to use
and in fact, you may never have need to use it. However, it is a feature that
powers a lot of the more clever forms of type inference and type checking that
you see in the language and in many popular TypeScript libraries.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">Yan </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">123 </span><span style="color:#ffa759;">extends </span><span style="font-style:italic;color:#5ccfe6;">number </span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5ccfe6;">true </span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">false</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">//   ^? type Yan = true
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">Tan </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;1&quot; </span><span style="color:#ffa759;">extends </span><span style="color:#ffcc66;">1 </span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5ccfe6;">true </span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">false</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">//   ^? type Tan = false
</span></code></pre>
<p>In this example, <code>Yan</code> evaluates to the literal boolean type <code>true</code> because
<code>123</code> extends <code>number</code>, and <code>Tan</code> evaluates to <code>false</code> because a string literal
type <code>"1"</code> does not extend the <code>number</code> literal <code>1</code>. Numbers are numbers, and
strings are not numbers.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="font-style:italic;color:#5c6773;">// a type level function that takes a single type as an argument
</span><span style="font-style:italic;color:#5c6773;">// and returns either the type `true` or the type `false`
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">Printable</span><span>&lt;</span><span style="color:#73d0ff;">T</span><span>&gt; </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5ccfe6;">true </span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">false</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">P </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">Printable</span><span>&lt;{ bar</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string </span><span>}&gt;</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">//   ^? type P = false
</span></code></pre>
<p><code>P</code> evaluates to <code>false</code> because the object type <code>{ bar: string }</code> is not a
<code>string</code>. The <code>Printable</code> type is effectively a type level function that takes a
single type as an argument and returns another type. As you can see, this is a
very powerful feature and is a large part of why what is often called the "type
level language" of TypeScript in many ways effectively its own small functional
programming language.</p>
<p>Enough about preliminaries, time to get to the meat of the matter.</p>
<h2 id="typescript-function-overloads-are-not-type-safe">TypeScript function overloads are not type safe</h2>
<p>TypeScript supports a form of overloaded functions, which is a common feature in
many languages that allows you to implement multiple related functions with a
common name. When you attempt to use that name to call a function, the
implementation that gets selected is usually determined by the type and/or arity
(number) of arguments you provide.</p>
<p>Before we look at TypeScript's version of overloading, let's look at a more
conventional example from Java of an overloaded method called <code>addToken</code>:</p>
<pre data-lang="java" style="background-color:#212733;color:#ccc9c2;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#ffa759;">class </span><span style="color:#73d0ff;">Scanner </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// This implementation takes a single argument of type `TokenType`
</span><span>    </span><span style="color:#ffa759;">private void </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">TokenType </span><span style="color:#ffcc66;">type</span><span>) {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// This implementation takes two arguments of type `TokenType` and `Object`
</span><span>    </span><span style="color:#ffa759;">private void </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">TokenType </span><span style="color:#ffcc66;">type</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5ccfe6;">Object </span><span style="color:#ffcc66;">literal</span><span>) {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ffa759;">private void </span><span style="color:#ffd580;">scanToken</span><span>() {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>        </span><span style="color:#ffa759;">switch </span><span>(c) {
</span><span>            </span><span style="color:#ffa759;">case </span><span style="color:#bae67e;">&#39;(&#39;</span><span style="color:#f29e74;">:
</span><span>                </span><span style="font-style:italic;color:#5c6773;">// This calls the first implementation
</span><span>                </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">TokenType</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">LEFT_PAREN</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>                </span><span style="color:#ffa759;">break</span><span style="color:#ccc9c2cc;">;
</span><span>                </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ffa759;">private void </span><span style="color:#ffd580;">string</span><span>() {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// This calls the second implementation
</span><span>        </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">TokenType</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">STRING</span><span style="color:#ccc9c2cc;">,</span><span> value)</span><span style="color:#ccc9c2cc;">;
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>The Java <code>Scanner</code> class has two implementations of <code>addToken</code>; one that takes a
single argument and another that takes two. Depending upon the arity (number of
arguments) and argument types, one of the two implementations is selected. The
convenience of this feature is that it groups implementations that conceptually
do the same thing, and saves defining separate names like <code>addToken</code> and
<code>addTokenWithLiteral</code> for all of the possible variants:</p>
<p>JavaScript does not have function overloads in the sense that Java does, and by
extension TypeScript also lacks function overloads in the conventional sense. At
runtime there is no enforcement that functions that take <code>n</code> number of arguments
must take <code>n</code> number of arguments - a fact some people unfamiliar with
JavaScript often find surprising. It is quite common in JavaScript APIs to have
functions that can take a wide variety of types and arity of arguments despite
the absence of overloads. So what TypeScript allows for is overloading function
<strong>signatures</strong>, but with a single implementation body:</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="font-style:italic;color:#5c6773;">// our Java addToken method example rewritten as function overloads in TypeScript
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="color:#ffcc66;">token</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TokenType</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">void</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="color:#ffcc66;">token</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TokenType</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">literal</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">any</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">void</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">addToken</span><span>(</span><span style="color:#ffcc66;">token</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TokenType</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">literal</span><span style="color:#f29e74;">?: </span><span style="font-style:italic;color:#5ccfe6;">any</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">void </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span>}
</span></code></pre>
<p>With TypeScript function overloads, we define multiple signatures, but only
implement a single function that must be compatible with all of the
non-implementing signatures. A frustration with this form of overloads is that
the type checker only enforces the signature of the implementing function, and
does not enforce that the implementing function satisfies all of the overloads.
In short, function overloads are not type safe. They were designed primarily to
help describe existing behavior of JavaScript APIs rather than help you
implement new ones.</p>
<p>For example, below has an implementing function that will fail to return the
correct value as indicated by the overload signatures. TypeScript will select
the second signature overload, but the implementing function will return the
wrong data type resulting in a runtime type error.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="font-style:italic;color:#5c6773;">// here we have two overloaded function signatures
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">yan</span><span>(</span><span style="color:#ffcc66;">tan</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">tethera</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">yan</span><span>(</span><span style="color:#ffcc66;">tan</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">tethera</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// the implementation signature must handle both cases from above,
</span><span style="font-style:italic;color:#5c6773;">// however, the return type of the implementation is not checked against the signatures above
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">yan</span><span>(</span><span style="color:#ffcc66;">tan</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">| </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">tethera</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">| </span><span style="font-style:italic;color:#5ccfe6;">number</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">| </span><span style="font-style:italic;color:#5ccfe6;">number </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// This implementing function body always returns a string,
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// which is incorrect for the second overload signature
</span><span>  </span><span style="color:#ffa759;">return </span><span style="color:#bae67e;">&quot;&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// When using the &#39;yan&#39; function with these arguments TypeScript
</span><span style="font-style:italic;color:#5c6773;">// will select the second overload signature
</span><span style="color:#ffa759;">const </span><span>num </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">yan</span><span>(</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;&quot;</span><span>)</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Expected return type: number
</span><span>num</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">toFixed</span><span>(</span><span style="color:#ffcc66;">0</span><span>)</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Runtime error: toFixed is not a function
</span></code></pre>
<h2 id="can-we-create-our-own-type-safe-function-overloads">Can we create our own type-safe function overloads?</h2>
<p>TypeScript function overloads are somewhat disappointing because the type
checker does not actually check our work. But is it possible to create a
function signature that does check our work? After surveying the features of
unions and control flow based narrowing, conditional types, and generics, many
users of the language construct something along these lines:</p>
<p><a href="https://www.typescriptlang.org/play?ssl=9&amp;ssc=1&amp;pln=23&amp;pc=2#code/PTAEBUAsEsGdTqAhqALgTwA4FNQBtsA3bPUAMwFcA7AY1WgHsrkqATZUGp16eppUhhxpISVKAC2STPBSxUAJ2hUA5vl7YFAtAw5cFC7LEzdlaodgBQF0AAUlE3tGIBZaQB5wobAA9U2NngAInQkKiDQAB9QINQwoIA+UABeCG8-ANZg0PDQAH5QeSVVUAAuUCoKCQAjTQBuS0sQCBh4FQDNaBpyajpGZiQaGmxMVFlCxTN1fy1SJFlmZUwKcTD2Q1QKBSp4VEhcfUNjUxKpTBx2MgUGCVAGLZ7aPmYAA3toKXpXaRfLVmwaHgkIZHn0mKB2qgAGoCCjYTzpfyBGI5CLRWLxBIACgA1th0OVwABKcrvRxfbBuTCeBINSxcHbiIpmGF4OEpCHYaGw7BYkLxIl1UDNACiPhwdGw6y5W2YFnKzNU9KY8gqVVqClZ7NSkK1vIx4UFwrAYol-mlm22aCw2HKlRqmkazQAcgwAO6gN24MT+CSjHQIP0ECQBcR7XC6nmg56WShPfqc7ls7AASSD2BDVDizwRviRWRR8SiMTi4WxeIJEBJdgcTm+1PASQA3pZQAgyKBcfiUslUvzDaAW222wzVTk9QrJiU+wBNMKgQg8oINYegDay0DjnlC5rgG2gADkipUB4Q8CoDFWsFg0BUVCQ1QIAZsB7JdcpHkbB9boAAvo022gDsu3QHs+1LIIiUHH8RxVMMwgnNUHQUDkABYACYV2HdcrVLPUdzAPdhAPe0NVPRALyvG87wfJ9UF0F83wpKkaW-Nt-x-PZrg9KhsA9EUDAYBQ+VdcQPkwYNQylSCGl-IA">Playground link</a></p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="font-style:italic;color:#5c6773;">// This is a type level function and a conditional type that maps
</span><span style="font-style:italic;color:#5c6773;">// a string literal to a corresponding type
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">PrimitiveMap</span><span>&lt;</span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="color:#bae67e;">&quot;yan&quot; </span><span style="color:#f29e74;">| </span><span style="color:#bae67e;">&quot;tan&quot;</span><span>&gt; </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="color:#bae67e;">&quot;yan&quot; </span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// This generic function accepts a string literal as an input and returns
</span><span style="font-style:italic;color:#5c6773;">// the corresponding mapped from our function `PrimitiveMap`
</span><span style="color:#ffa759;">declare function </span><span style="color:#ffd580;">getValue</span><span>&lt;</span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="color:#bae67e;">&quot;yan&quot; </span><span style="color:#f29e74;">| </span><span style="color:#bae67e;">&quot;tan&quot;</span><span>&gt;(</span><span style="color:#ffcc66;">key</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">T</span><span>)</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">PrimitiveMap</span><span>&lt;</span><span style="color:#73d0ff;">T</span><span>&gt;</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">const </span><span>stringValue </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">getValue</span><span>(</span><span style="color:#bae67e;">&quot;yan&quot;</span><span>)</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Expected return type: string
</span><span style="color:#ffa759;">const </span><span>numberValue </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">getValue</span><span>(</span><span style="color:#bae67e;">&quot;tan&quot;</span><span>)</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Expected return type: number
</span></code></pre>
<p>Well this looks very promising! If you inspect the values of <code>stringValue</code> and
<code>numberValue</code> we get completely different return types from the same function
depending upon the input value, and they all appear to be correct. This looks a
lot like TypeScript function overloading!</p>
<p>As with the previous examples, we have a single implementing function. However,
this function takes a single argument <code>T</code> that is a generic with the constraint
of <code>"yan" | "tan"</code>. That generic value is passed into a type level function
called <code>PrimitiveMap</code> as the return type of the function. This conditional type
will pick the appropriately matching return type given the input argument. It
would appear that we have successfully recreated TypeScript function overloading
using other features of the language.</p>
<p>This is the point of frustration for users because when they turn to
implementing the function, they find that they cannot implement its body. The
only way we could implement the body of getAction is if we assert that the
return value is <code>PrimitiveMap&lt;T&gt;</code>. Asserting this defeats the entire purpose of
this exercise, which was to create a type-safe overload.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="font-style:italic;color:#5c6773;">// Now we attempt to implement the getValue function
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">getValueImplementation</span><span>&lt;</span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="color:#bae67e;">&quot;yan&quot; </span><span style="color:#f29e74;">| </span><span style="color:#bae67e;">&quot;tan&quot;</span><span>&gt;(
</span><span>  </span><span style="color:#ffcc66;">key</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">T</span><span style="color:#ccc9c2cc;">,
</span><span>)</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">PrimitiveMap</span><span>&lt;</span><span style="color:#73d0ff;">T</span><span>&gt; {
</span><span>  </span><span style="color:#ffa759;">if </span><span>(key </span><span style="color:#f29e74;">=== </span><span style="color:#bae67e;">&quot;yan&quot;</span><span>) {
</span><span>    </span><span style="color:#ffa759;">const </span><span>yanValue</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;Yan value&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#ffa759;">return </span><span>yanValue</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Type &#39;string&#39; is not assignable to type &#39;PrimitiveMap&lt;T&gt;&#39;
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#ffa759;">if </span><span>(key </span><span style="color:#f29e74;">=== </span><span style="color:#bae67e;">&quot;tan&quot;</span><span>) {
</span><span>    </span><span style="color:#ffa759;">const </span><span>tanValue</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">42</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#ffa759;">return </span><span>tanValue</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Type &#39;number&#39; is not assignable to type &#39;PrimitiveMap&lt;T&gt;&#39;
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#ffa759;">throw </span><span style="color:#f29e74;">new </span><span style="color:#73d0ff;">Error</span><span>(</span><span style="color:#bae67e;">&quot;Not implemented&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>The stumbling block here is in the presence of generic types. As of today,
evaluation of conditional types is deferred until the generic value is resolved,
which only happens when the function is called. The conditional return type of
<code>getValueImplementation</code> will only be evaluated when the function is called and
not when the function body is being implemented.</p>
<p>In TypeScript you cannot evaluate a conditional type level function like
<code>PrimitiveMap</code> if you give it a generic argument because of this fact. A simple
illustration of this limitation can be seen below. Despite the fact that <code>T</code> has
a constraint that it extends <code>string</code>, the conditional type remains unevaluated
within the body of the function <code>tan</code> because <code>T</code> is a generic type.</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">A </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#ffa759;">extends </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5ccfe6;">true </span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">false</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">//   ^? type A = true
</span><span>
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">tan</span><span>&lt;</span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="font-style:italic;color:#5ccfe6;">string</span><span>&gt;(</span><span style="color:#ffcc66;">_</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">T</span><span>) {
</span><span>  </span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">B </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">T </span><span style="color:#ffa759;">extends </span><span style="font-style:italic;color:#5ccfe6;">string </span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5ccfe6;">true </span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">false</span><span style="color:#ccc9c2cc;">;
</span><span>  </span><span style="font-style:italic;color:#5c6773;">//   ^? type B = T extends string ? true : false;
</span><span>}
</span></code></pre>
<h2 id="so-what-can-we-do">So what can we do?</h2>
<p>In both the built-in function overloads and our experimentation with combining
other language features, we have failed to achieve type-safe overloading
function bodies. While we created nice APIs for consumers, implementers get no
help from the compiler.</p>
<h3 id="solution-1-implement-separate-functions">Solution 1: Implement separate functions</h3>
<p>Take a step back. Reconsider the problem the Java case was trying to solve. They
had separate implementations with a common name, which isn't a feature of
JavaScript. As I suggested earlier, the alternative in the Java case is to
simply have different names for each implementation. So the solution is staring
right at us. Have separately named function implementations for each of your
"overloads."</p>
<pre data-lang="ts" style="background-color:#212733;color:#ccc9c2;" class="language-ts "><code class="language-ts" data-lang="ts"><span style="color:#ffa759;">function </span><span style="color:#ffd580;">createYan</span><span>()</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Yan </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5c6773;">//...
</span><span>}
</span><span>
</span><span style="color:#ffa759;">function </span><span style="color:#ffd580;">createTan</span><span>()</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Tan </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5c6773;">//...
</span><span>}
</span></code></pre>
<p>Primarily the purpose of TypeScript function overloads is to provide a good
experience for users of existing APIs and potentially for library authors. If
you are not in one of those categories, then it might be best to avoid the
complexity of trying to implement function overloads in TypeScript and the
testing burden it might introduce.</p>
<h3 id="solution-2-sacrifice-type-safety-for-the-user-s-benefit">Solution 2: Sacrifice type safety - for the user's benefit</h3>
<p>If you are, say, a library author, it might be nice to have overloading function
signatures to give your users a pleasant API to use. Here, the advice would be
to accept that you will have to do extra work to ensure that you are satisfying
overloaded signatures. This will be in the form of extensive testing. This is a
corner of the language where you aren't going to get much compiler help, but it
might be a worthwhile sacrifice for your users.</p>
<p>Additionally, you could make use of <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions">runtime assertions</a> or <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type guards</a>
to pass the function arguments to more specialized functions like in solution 1
example.</p>
<p>So in conclusion, I have only partial solutions to the problem of implementing
typesafe function overloads in TypeScript. So yeah... sorry about that! However,
the more important point was it's clear to see why someone might think combining
these features might work and maybe in future versions of TypeScript it might,
though I suspect it might not be a priority and might incur performance or
complexity costs for implementors and users of conditional types.</p>
</section>
</article>

    </main>

    <footer class="footer">
      <ul class="f5 contacts">
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://bsky.app/profile/m-rutter.com" aria-label="bsky">
            <i class="fa-solid fa-square" style="color: #3377f6;"></i> @m-rutter.com
          </a>
        </li>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://github.com/m-rutter" aria-label="github">
            <i class="fab fa-github" aria-hidden="true"></i> /m-rutter
          </a>
        </li>
        <li><i class="fa fa-globe" aria-hidden="true"></i> London-ish, UK</li>
      </ul>
    </footer>
  </body>
</html>
